latest done:
* create swagger / openapi spec
* clean up and fix user endpoints in backend
* cleaner terraform approach for specifying api gateway endpoints
* openapi docs
* added some hard-coded version identifiers to make it easy to verify the deployed code version

in progress:
* get the authentication et al working for the deployed endpoints - login, sign up, status page

next steps:
* make sure users updated_at is NOT updated just for setting last_login_at (if need be, pull that into a separate user_activities table, which may be useful anyway... though is log-ish so has HIGH growth potential)
* add simple version identifiers for FE and BE so the deployed versions can be identified (add to FE status page, and BE ping response)

longer term:
* the backend is making DB queries directly with SQL - think about whether this is a decent approach for this case or whether it'd be better to use some sort of ORM
* set up branch protection in github & shift workflow to branches and merges rather than direct commits (allow self-review, since solo, but add notes about it to README)
* iron out CI/CD for deployments & Terraform
* deploy FE via ci-cd (to dev environment)
* deploy BE via ci-cd (to dev environment)
* DB change deployment and migration via CI-CD (to dev environment)
* do a dev rollback (FE, BE, DB)
* implement / set up a prod environment
* do a prod deploy
* do a prod rollback (FE, BE, DB)
* create/implement invite-a-friend

docs/wiki/README
* development tooling set up
* AWS set up- basic org & account, initial terraform gotchas (set secrets, create ecr registries, etc.)
* running things locally using docker
* general workflow for FE update/deployment, and also BE and DB
* details of CI/CD flow
* architecture diagram
* scaling handles / levers
* logs & monitors
